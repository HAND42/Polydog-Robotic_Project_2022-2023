# SESSION 20 OUTCOME REPORT
## Date: 25/04/2023
## Main event of the session: Establishing Communication and Sending Joint Values for Robot Control.     
   
During this session, we worked on establishing communication between a the computer and Jetson Nano using ROS. Our goal was to send joint values generated by the simulation of the Polydog in CoppeliaSim to the Jetson Nano. The Jetson Nano then sends these values to the Arduino, which in turn sends them to the Lynxmotion SSC-32U controller. The SSC-32U controller finally sends the joint values to the servo motors, making the robot dog move.  
To achieve this, we used ROS (Robot Operating System). We first installed ROS melodic on UBUNTU 18.04 and set up a ROS workspace and created a package for our project. We then created a ROS node to receive the joint values from the Polydog simulation in CoppeliaSim and publish them to a ROS topic.
Here is the code responsible for sending the joints values to ROS in coppeliaSim:    
`function sysCall_init()`  
    `if simROS then1`  
        `jointStatePub = simROS.advertise('/JointStates','sensor_msgs/JointState')`  
        `subscriber=simROS.subscribe('/JointStates','sensor_msgs/JointState' 'subscriber_callback')`  
    `end`   
     `robotHandle=sim.getObjectHandle(sim.handle_self)`      
     `sholderj1Handle = sim.getObjectHandle('Shoulder1')`  
     `elbowj1Handle = sim.getObjectHandle('Hip1')`   
     `legj1Handle = sim.getObjectHandle('Knee1')`  
     `sholderj2Handle = sim.getObjectHandle('Shoulder2')`  
     `elbowj2Handle = sim.getObjectHandle('Hip2')`   
     `legj2Handle = sim.getObjectHandle('Knee2')`  
     `sholderj3Handle = sim.getObjectHandle('Shoulder3')`  
     `elbowj3Handle = sim.getObjectHandle('Hip3')`  
     `legj3Handle = sim.getObjectHandle('Knee3')`  
     `sholderj4Handle = sim.getObjectHandle('Shoulder4')`  
     `elbowj4Handle = sim.getObjectHandle('Hip4')`  
     `legj4Handle = sim.getObjectHandle('Knee4')`  
`end`  
`function sendJointStates()`  
     `sj1=(sim.getJointPosition(sholderj1Handle)*180/math.pi)`  
     `ej1=(sim.getJointPosition(elbowj1Handle)*180/math.pi)`  
     `lj1=(sim.getJointPosition(legj1Handle)*180/math.pi)`  
     `sj2=(sim.getJointPosition(sholderj2Handle)*180/math.pi)`  
     `ej2=(sim.getJointPosition(elbowj2Handle)*180/math.pi)`  
     `lj2=(sim.getJointPosition(legj2Handle)*180/math.pi)`  
     `sj3=(sim.getJointPosition(sholderj3Handle)*180/math.pi)`  
     `ej3=(sim.getJointPosition(elbowj3Handle)*180/math.pi)`  
     `lj3=(sim.getJointPosition(legj3Handle)*180/math.pi)`  
     `sj4=(sim.getJointPosition(sholderj4Handle)*180/math.pi)`  
     `ej4=(sim.getJointPosition(elbowj4Handle)*180/math.pi)`  
     `lj4=(sim.getJointPosition(legj4Handle)*180/math.pi)`  
`return`  
 `{`  
   ` header = {seq=0,stamp=simROS.getTime(),frame_id='Realname'},`  
    `name = {},` 
    `position = {sj1,ej1,lj1,sj2,ej2,lj2,sj3,ej3,lj3,sj4,ej4,lj4},`  
    `velocity = {},`  
    `effort = {}`           
 `}`  
`end `  
`function sysCall_actuation()`  
`-- Send the Joint Angles of the robot:`  
    `--if not pluginNotFound then`  
    `if simROS then`  
            `simROS.publish(jointStatePub,sendJointStates())`  
    `end`  
`end`  
`function sysCall_cleanup()`  
    `-- Following not really needed in a simulation script (i.e. automatically shut down at simulation end):`  
    `if simROS then`  
        `simROS.shutdownPublisher(jointStatePub)`  
        `simROS.shutdownSubscriber(subscriber)`  
    `end`  
`end`  
Here we created a topic called /JointStates, coppeliaSim publish to this topic the joints values. So if we want to check if really ROS recieve the message (joint values) in /Joinstates. we enter this commands in the terminal :
`roscore`   
`rostopic list`
`rostopic echo /JointStates`
Here is what the terminal shows:  
![Alt text](S20/ROS_joint_values.gif)  
We can clearly see that the extraction of the joint values from CoppeliaSim and their publication to the topic /JointStates has been successfully achieved.  
I then wrote a cpp file in the ROS workspace called listener , that will subscribe to the /JointStates topic in order to get the joint values and store them in variables.  
`#include <ros/ros.h>`  
`#include <sensor_msgs/JointState.h>`  
`#include <iostream>`  
`#include <boost/format.hpp>`  
`using namespace std;`  
`void jointStateCallback(const sensor_msgs::JointState::ConstPtr& msg)`  
`{`  
  `// Access joint names`  
  `//std::vector<std::string> joint_names = msg->name;`  
  `// Access joint positions`  
  `const double* joint_positions = msg->position.data();`  
  `const size_t joint_positions_size = msg->position.size();`  
  `float joint_values[12] = {joint_positions[0], joint_positions[1], joint_positions[2], joint_positions[3], joint_positions[4], joint_positions[5], joint_positions[6], joint_positions[7], joint_positions[8], joint_positions[9], joint_positions[10], joint_positions[11]};`  
  `// Access joint velocities`  
  `//std::vector<double> joint_velocities = msg->velocity;`  
  `// Access joint efforts`  
  `//std::vector<double> joint_efforts = msg->effort;`  
    `//std::cout << joint_positions[0];`  
    `//print (joint_positions[0]);`  
    `// Format the table as a string`  
    `boost::format table_format("[%1%, %2%, %3%, %4%, %5%, %6%, %7%, %8%, %9%, %10%, %11%, %12%]");`  
    `string table_string = (table_format % joint_values[0] % joint_values[1] % joint_values[2] % joint_values[3] % joint_values[4] % joint_values[5] % joint_values[6] % joint_values[7] % joint_values[8] % joint_values[9] % joint_values[10] % joint_values[11]).str();`  
    `// Print the table to the console using ROS_INFO`  
    `ROS_INFO("%s", table_string.c_str());`  
`}`  
`int main(int argc, char** argv)`   
`{`  
  `// Initialize ROS node`   
  `ros::init(argc, argv, "listener");`  
  `// Create node handle`  
  `ros::NodeHandle n;`  
  `// Create subscriber`  
  `ros::Subscriber sub = n.subscribe("/JointStates", 1000, jointStateCallback);`  
  `// Spin`  
  `ros::spin();`  
  `return 0;`  
`}`  

During the rest of the session, I made the decision to delay sending the joint values from ROS to the Jetson Nano and instead focus on testing if we could send these values directly from ROS to the Arduino on the same computer (i just want to learn the process in order to apply it to jetson nano after sending the values to it). To accomplish this, we began researching and discovered two useful packages: rosserial-arduino and rosserial.Rosserial-arduino is a ROS package that enables communication between a ROS node and an Arduino board via serial communication. This package provides a way to serialize and deserialize ROS messages on the Arduino board and provides a way to communicate with the ROS node using standard ROS message formats.The rosserial package, on the other hand, is a generic implementation of the rosserial protocol. It provides a way to communicate between a ROS node and an embedded system via serial communication, such as with an Arduino.To send information from ROS to the Arduino using these packages, we first need to create a ROS node that publishes the joint values to a ROS topic. We can then use the rosserial-arduino package to generate a library for the Arduino that allows it to subscribe to this topic and receive the joint values. The library is created using the rosserial_client package, which is included with the rosserial-arduino package.Once the library is generated, we can include it in our Arduino sketch and use it to receive the joint values from the ROS node. The rosserial-arduino library takes care of serializing and deserializing the ROS messages, so we don't need to worry about the details of the communication protocol.  
I installed these packages and start writing a cpp file that will send the joint values to Arduino. However, I discovered a new method of sending these values directly from CoppeliaSim to the Arduino via serial communication without the use of ROS. We decided to test this new method and found that it worked, allowing us to send the joint values directly to the Arduino board. After successfully sending the joint values to the Arduino, my colleague Hugo began working on the next step, which is to send these values from the Arduino to the servo motors.